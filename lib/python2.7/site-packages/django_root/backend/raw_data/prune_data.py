import datetime
import json
import os
import subprocess
import sys
import urllib

from lxml import etree
from unidecode import unidecode

OUTPUT_DIR = os.path.dirname(os.path.abspath(__file__))

#A dictionary of indices that must be present in order for the
#entry to be considered valid and not thrown out
INDICES = {
    'wine': [-3],
    'beer': [4]
}

#An array of possible wine styles in the dataset
WINE_STYLES = ['Pinot Noir', 'Cabernet Sauvignon', 'Zinfandel',
		'Guarda No 1', 'Chardonnay', 'Estate Port', 
		'Camartina', 'Williamette Valley', 'Zinfandel Port',
		'Cabernet Sauvignon Port', 'La Tache', 'Riesling',
		'Vinas Malbec', 'Opus One', 'Syrah', 'Red Wine', 
		'Cosecha Tardia', 'Rouge']

#A set of keywords in the existing data set that will be used
#for Google Maps API queries in def geocode()
GEOCODE_KEYWORDS = set([
    'brewery_brand',
    'from_region',
    'wine_producer',
    'region'
])


class TSVParser:
    """A class to parse a TSV file and create XML and JSON
    representations of it"""
    
    def __init__(self, infile, style):
	"""Returns a dictionary representation of the TSV files
	`infile` of beverage type `style`"""
	tsv = None
	with open(infile, 'r') as f:
	    tsv = f.readlines()
	
	self.style = style
	self.titles = {}
	self.data = []
	count = 0

	#Establish self.titles
	for title in tsv[0].split('\t'):
	    self.titles[count] = title.strip()
	    count += 1
	
	#Establish self.data, throw out incomplete entries
	for line in tsv[1:]:
	    if self.check_sparse(line.split('\t')):
		clean_data = []
		for datum in line.split('\t'):
		    clean_data.append(unidecode(datum.strip()))
		self.data.append(clean_data)
    
    def check_sparse(self, lst):
	"""Returns True if an entry is non-sparse according to INDICES"""
	return all(lst[i] for i in INDICES[self.style]) 

    def generate_XML(self):
	"""Generates an XML representation of the TSV file"""
	#Create the XML
	root = etree.Element('%s_catalogue' % self.style)
	
	for instance in self.data:
	    sub_root = etree.SubElement(root, self.style)

	    geocode_terms = []
	    for i in range(len(instance)):
		etree.SubElement(sub_root, self.titles[i]).text = instance[i]
		if self.titles[i] in GEOCODE_KEYWORDS:
		    geocode_terms.extend(instance[i].split(' '))
	    etree.SubElement(sub_root, 'address').text = result
	    self.geocode(' '.join(geocode_terms))

	#Write the XML
	f = open('./%s_catalogue.xml' % self.style, 'w')
	f.write('<?xml version="1.0" encoding="UTF-8" ?>\n\n')
	now = datetime.datetime.now()
	header='<!-- %s_catalogue.xml  Created: ' % self.style + \
	    now.strftime('%Y-%m-%d %H:%M') + ' -->\n\n'
	f.write(header)
	f.write(etree.tostring(root, pretty_print=True))
	f.close()

    def generate_JSON(self):
	"""Generates a JSON Django model fixture of the TSV file"""
	#Create the JSON object
	wine_json_obj = []
	winery_json_obj = []
	wineries = set()
	wine_no = 1
	winery_no = 1

	for instance in self.data:
	    wine_attributes = {'model': 'wines.wine', 'pk': wine_no}
	    winery_attributes = {'model': 'wines.wineprodcuer', 'pk': winery_no}

	    wine_fields = {'fields': {}}
	    winery_fields = {'fields': {}}
	    geocode_terms= []

	    for i in range(0,len(instance)):
		#Remove useless data wine_fields
		if (self.titles[i] == 'grape_variety' or self.titles[i] == 'nv'
			or self.titles[i] == 'id'):
		    continue
		
		if instance[i]:	
		    #Create the address search query
		    if self.titles[i] in GEOCODE_KEYWORDS:
			geocode_terms.extend(instance[i].split(' '))
		    
		    #Remove vintage ranges	
		    if self.titles[i] == 'vintage':
			wine_fields['fields'][self.titles[i]] = instance[i][0:4]
		    
		    #Add new winery addresses
		    elif self.titles[i] == 'wine_producer':
			address = self.geocode(' '.join(geocode_terms))
			if address:
			    wine_fields['fields']['wine_producer'] = instance[i]
			    wine_fields['fields']['address'] = address
			    if not instance[i] in wineries:
				winery_fields['fields']['name'] = instance[i]
				winery_fields['fields']['address'] = address
				wineries.add(instance[i])	
		    else:
			wine_fields['fields'][self.titles[i]] = instance[i]
		    
		    #Get proper wine style
		    if self.titles[i] == 'name':
			wine_fields['fields']['style'] = self.get_style(instance[i])
	    
	    if not 'wine_producer' in wine_fields['fields']:
		continue

	    wine_attributes.update(wine_fields)
	    winery_attributes.update(winery_fields)

	    wine_json_obj.append(wine_attributes)
	    wine_no += 1
	    if winery_fields['fields']: #Only add unique wineries
		winery_json_obj.append(winery_attributes)
		winery_no += 1
	
	#Write the JSON files
	filename = '%s_catalogue_fixture.json' % self.style
	f = open(os.path.join(OUTPUT_DIR, filename), 'w')
	f.write(json.dumps(wine_json_obj, sort_keys=True, indent=4))
	f.close()
    
	filename = '%sry_catalogue_fixture.json' % self.style
	f = open(os.path.join(OUTPUT_DIR, filename), 'w')
	f.write(json.dumps(winery_json_obj, sort_keys=True, indent=4))
	f.close()

    def get_style(self, name):
	"""Given a complete wine name, return the style name"""
	for style in WINE_STYLES:
	    if name.endswith(style):
		return style
    
    def geocode(self, name):
	"""Given a business name `name`, returns the best address match
	using the Google Maps API"""
	if not name:
	    return
	#Build a '+' delimited query string
	query = urllib.quote('+'.join(name.split(' ')))
	html = subprocess.check_output(
	    ['curl', '-i', 'http://maps.google.com/maps?q=%s' % query])
	#Find the slice of text that contains the most relevant address
	index = html.find('icon_id:')
	substring = html[index:index+500].split(':')
	for i in range(len(substring)):
	    if substring[i].find('laddr') != -1:
		return unidecode(substring[i+1].split('\'')[1].decode('string-escape'))

    def __repr__(self):
	"""A string representation of the data in the CSV"""
	valid = 0
	s = ''
	for x in range(len(self.data)): 
	    for i in range(len(self.titles) - 1):
		s += '%s, %s\n' % (self.titles[i], str(self.data[x][i]))
		valid += 1
	    s += '----------\n'

	s += 'Valid entries: %i\n' % valid
	return s

if __name__ == '__main__':
    if len(sys.argv) < 3:
	print 'Usage: prune_data.py `/path/to/tsv/` `style_of_libation`'
    else:
	x = TSVParser(sys.argv[1], sys.argv[2])
	x.generate_JSON()
