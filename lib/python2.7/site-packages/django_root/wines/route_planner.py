import json
import numpy
import os
import urllib2

from scipy.sparse.csgraph import dijkstra
from models import Wine, WineProducer
from operator import itemgetter
from greedy_tsp import solve_tsp_numpy

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
METRIC = {
    'km': 1000,
    'm': 1
}

tour_distance = []
max_min_distance = -1
tolerance = 3
num_wineries = 0
num_constraints = 0

#logfile = open("tour.log", "w")

def get_coordinates(id):
    """Given the `id` of a WineProducer, return the latitude and 
    longitude of the WineProducer as a tuple"""
    response = urllib2.urlopen('http://maps.googleapis.com/maps' + \
		'/api/geocode/json?address=%s&sensor=false' \
		% WineProducer.objects.get(id=id).address.replace(' ', '+'))
    try:
	obj = json.loads(response.read())['results'][0]['geometry']['location']
	return (float(obj['lat']), float(obj['lng']))
    except (KeyError, IndexError):
	return 

def get_distance_matrix(ids):
    """Given an array of WineProducer ids, returns a distance matrix
    of the distances between each point, and a dictionary that maps
    the rows/cols to the name of the WineProducer it represents"""
    row_to_name = {}
    coordinate_string = ''
    count = 0
    for id in ids:
	coordinates = get_coordinates(id)
	if not coordinates: continue
	coordinates = '%s,%s' % coordinates	
	coordinate_string += '%s|' % coordinates
	row_to_name[count] = WineProducer.objects.get(id=id).name
	count += 1
    if not coordinate_string:
	raise ValueError('No valid coordinates could be obtained')
    response = urllib2.urlopen('http://maps.googleapis.com/maps' + \
		'/api/distancematrix/json?origins=%s&destinations=%s&sensor=false' \
		% (coordinate_string, coordinate_string))
    obj = json.loads(response.read())
    if obj['status'] == u'OVER_QUERY_LIMIT':
	raise ValueError('Number of addresses is too large for Google API')
   
    #Build distance matrix
    matrix = numpy.zeros((len(row_to_name), len(row_to_name)))
    r = 0
    for row in obj['rows']:
	c = 0
	for elem in row['elements']:
	    #Enforce symmetry (inconsistent Google API results)
	    if r == c:
		matrix [r, c] = 0
	    elif matrix[c, r]:
	    	matrix[r, c] = matrix[c,r]
	    else:
		try:
		    matrix[r, c] = metric_convert(elem['distance']['text'])
		except KeyError:
		    raise ValueError('Custom lat/lng coordinates are invalid')
	    c += 1
	r += 1

    return (matrix, row_to_name)

def metric_convert(string):
    distance, unit = string.split(' ')
    return float(distance.replace(',', '')) * METRIC[unit]

def get_shortest_tours(dist_matrix, constraint_matrix, num_results, min_wineries, max_wineries):
    """Given a distance matrix where the first row/column corresponds to the source and each row/colum after that is ordered by increasing distance fromt he source,
        a constraint matrix for the wineries the number of results desired, the minimum number of wineries in a tour, and the maximum number of wineries in a tour,
	give a list of the shortest tours ordered by increasing distance"""
    
    num_wineries = len(constraint_matrix)
    num_constraints = len(constraint_matrix[0])
    
    def calculate_tour_distance(possible_tour):
	tour = [0] + [x+1 for x in possible_tour] # Because the 0 index in the distance matrix is for the source and incoming indices are one too low
	return solve_tsp_numpy(tour, dist_matrix)
    
    def made_improvement(possible_tour):
        global tour_distance, max_min_distance
	if max_min_distance < 0:
            x = calculate_tour_distance(possible_tour)
	    tour_distance.append(x)
	    max_min_distance = tour_distance[0][1]
	    return True
	else:
	    calculated_tour = calculate_tour_distance(possible_tour)
	    if len(tour_distance) < num_results:
		tour_distance.append(calculated_tour)
		tour_distance = sorted(tour_distance, key=itemgetter(1))
		max_min_distance = tour_distance[len(tour_distance)-1][1]
		return True
	    elif calculated_tour[1] < max_min_distance:
		tour_distance[num_results-1] = calculated_tour
		tour_distance = sorted(tour_distance, key=itemgetter(1))
		max_min_distance = tour_distance[len(tour_distance)-1][1]
		return True
	return False
    
    def vec_or(vector1, vector2):
        ret = []
        for x in range(len(vector1)):
            ret.append(vector1[x] or vector2[x])
        return ret
    
    def meets_constraints(possible_tour, constraint_matrix):
	"""Checks whether a given possible tour satisfies all of the constraints"""
	constraint_vector = [0]*num_constraints
	for x in possible_tour:
	    constraint_vector = vec_or(constraint_vector, constraint_matrix[x])
	for y in constraint_vector:
	    if not y:
		return False
	return True
    
    def build_tour_list(consecutive_nonimprovements, possible_tour, indent):
        global tour_distance
	len_current_tour = len(possible_tour)
        #logfile.write(indent + "Possible tour: " + str(possible_tour)+"\n" + indent + "Consecutive nonimprovements: " + str(consecutive_nonimprovements) + "\n")
        if (consecutive_nonimprovements > tolerance and len(tour_distance) == num_results) or len_current_tour - 1 > max_wineries:
            return
        if meets_constraints(possible_tour, constraint_matrix):
            #logfile.write(indent + "Meets constraints\n")
            if len_current_tour < min_wineries and possible_tour[len_current_tour-1] + 1 < num_wineries:
                build_tour_list(consecutive_nonimprovements, possible_tour + [possible_tour[len_current_tour-1] + 1], indent + "    ")
            elif made_improvement(possible_tour):
                #logfile.write(indent + "Made improvement\n")
                if possible_tour[len_current_tour-1] + 1 < num_wineries:
                    build_tour_list(0, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], indent + "    ")
            else:
                #logfile.write(indent + "Didn't make improvement\n")
                if possible_tour[len_current_tour-1] + 1 < num_wineries:
                    build_tour_list(consecutive_nonimprovements + 1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], indent + "    ")
        elif possible_tour[len_current_tour-1] + 1 < num_wineries:
            if len_current_tour < min_wineries or len_current_tour < num_constraints:
                build_tour_list(consecutive_nonimprovements, possible_tour + [possible_tour[len_current_tour-1]+1], indent + "    ")
            build_tour_list(consecutive_nonimprovements+1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], indent + "    ")
    
    build_tour_list(0, [0], "")
    print tour_distance
